<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>100 Games in 1 - Retro TV Dashboard</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <main class="viewport">
      <div class="scanlines"></div>
      <section class="tv-shell" aria-label="Retro television dashboard">
        <div class="tv-chrome">
          <div class="tv-bezel">
            <div class="tv-screen" role="presentation">
              <div class="screen-overlay"></div>
              <div class="screen-content">
                <header class="screen-header">
                  <p class="session-label">Session 1987-A</p>
                  <p class="clock">12:00</p>
                </header>
                <div class="screen-body">
                  <div class="screen-panel screen-panel--menu" data-panel="menu">
                    <div class="title-logo">
                      <span class="logo-shadow">100</span>
                      <span class="logo-main">100</span>
                      <span class="logo-sub">Games in 1</span>
                    </div>
                    <div class="menu-frame">
                      <p class="menu-label">Arcade Status Board</p>
                      <ul class="menu-list" role="menu">
                        <li class="menu-item active" role="menuitem">
                          <div class="menu-item__headline">
                            <span class="menu-item__name">Color Match</span>
                            <span class="menu-item__status menu-item__status--ok">Ready · combos primed</span>
                          </div>
                          <p class="menu-item__detail">Calibration perfect — palette seeds refreshed for the next challenger.</p>
                        </li>
                        <li class="menu-item" role="menuitem">
                          <div class="menu-item__headline">
                            <span class="menu-item__name">Quick Tap</span>
                            <span class="menu-item__status menu-item__status--warn">Warmup</span>
                          </div>
                          <p class="menu-item__detail">Beat the blinking pads to keep the multiplier alive.</p>
                        </li>
                        <li class="menu-item" role="menuitem">
                          <div class="menu-item__headline">
                            <span class="menu-item__name">Hyper Run</span>
                            <span class="menu-item__status menu-item__status--blocked">Caution</span>
                          </div>
                          <p class="menu-item__detail">Obstacles are spawning fast — stay light on the boost trigger.</p>
                        </li>
                        <li class="menu-item" role="menuitem">
                          <div class="menu-item__headline">
                            <span class="menu-item__name">Snake Sprint</span>
                            <span class="menu-item__status menu-item__status--new">New routes</span>
                          </div>
                          <p class="menu-item__detail">Arena walls reshuffled — grab the fruit without clipping the tail.</p>
                        </li>
                      </ul>
                    </div>
                    <footer class="screen-footer">
                      <p>Load up a mini game, start the arcade marathon, or scout the library.</p>
                    </footer>
                  </div>
                  <div class="screen-panel screen-panel--browser" data-panel="browser" hidden>
                    <div class="browser-header">
                      <p class="browser-title">Game Library</p>
                      <button type="button" class="browser-close" aria-label="Return to dashboard">Back</button>
                    </div>
                    <p class="browser-subtitle">Select a mini game to open it in a separate window.</p>
                    <ul class="applet-grid" role="list"></ul>
                    <p class="browser-hint">Games open in a new tab so you can focus on the current challenge.</p>
                  </div>
                  <div class="screen-panel screen-panel--marathon" data-panel="marathon" hidden>
                    <header class="marathon-header">
                      <h2 class="marathon-title">Arcade Marathon</h2>
                      <p class="marathon-subtitle">Play every mini game back-to-back.</p>
                    </header>
                    <div class="marathon-stats" role="status">
                      <div class="marathon-stat">
                        <span class="marathon-stat__label">Games cleared</span>
                        <span class="marathon-stat__value" id="marathon-wins">0</span>
                      </div>
                      <div class="marathon-stat">
                        <span class="marathon-stat__label">Current challenge</span>
                        <span class="marathon-stat__value" id="marathon-current">---</span>
                      </div>
                      <div class="marathon-stat">
                        <span class="marathon-stat__label">Total games</span>
                        <span class="marathon-stat__value" id="marathon-total">0</span>
                      </div>
                    </div>
                    <div class="marathon-stage" id="marathon-stage">
                      <div class="marathon-frame-slot" id="marathon-frame-slot" aria-live="polite"></div>
                      <p class="marathon-message" id="marathon-message">Launch the arcade marathon to start the run.</p>
                    </div>
                    <div class="marathon-actions">
                      <button type="button" class="browser-close" id="marathon-exit">Exit Marathon</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <aside class="control-column" aria-label="Television controls">
            <div class="control-group">
              <button class="knob knob--large" aria-label="Power knob"></button>
              <div class="knob-label">Power</div>
            </div>
            <div class="control-group">
              <button class="knob knob--medium" aria-label="Playlist select"></button>
              <div class="knob-label">Playlist</div>
            </div>
            <div class="control-group">
              <button class="knob knob--small" aria-label="Volume"></button>
              <div class="knob-label">Volume</div>
            </div>
            <div class="control-stack">
              <button class="job-pill" type="button" id="open-game-browser">Game library · browse mini games</button>
              <button class="job-pill" type="button" id="start-marathon">Arcade marathon · play all in sequence</button>
              <button class="job-pill" type="button">Color Match · review streak tips</button>
              <button class="job-pill" type="button">Quick Tap · check leaderboard</button>
            </div>
          </aside>
        </div>
        <div class="tv-base"></div>
        <div class="glow halo"></div>
        <div class="glow ambient"></div>
      </section>
    </main>
    <script>
      (() => {
        const openButton = document.getElementById('open-game-browser');
        const startMarathonButton = document.getElementById('start-marathon');
        const menuPanel = document.querySelector('[data-panel="menu"]');
        const browserPanel = document.querySelector('[data-panel="browser"]');
        const marathonPanel = document.querySelector('[data-panel="marathon"]');
        const closeButton = browserPanel?.querySelector('.browser-close');
        const marathonExitButton = document.getElementById('marathon-exit');
        const screenBody = document.querySelector('.screen-body');
        const appletGrid = browserPanel?.querySelector('.applet-grid');
        const marathonFrameSlot = document.getElementById('marathon-frame-slot');
        const marathonMessage = document.getElementById('marathon-message');
        const marathonWins = document.getElementById('marathon-wins');
        const marathonCurrent = document.getElementById('marathon-current');
        const marathonTotal = document.getElementById('marathon-total');
        const repoRootUrl = new URL('../../', window.location.href);

        if (
          !openButton ||
          !startMarathonButton ||
          !menuPanel ||
          !browserPanel ||
          !marathonPanel ||
          !closeButton ||
          !marathonExitButton ||
          !screenBody ||
          !appletGrid ||
          !marathonFrameSlot ||
          !marathonMessage ||
          !marathonWins ||
          !marathonCurrent ||
          !marathonTotal
        ) {
          return;
        }

        let hasLoadedRegistry = false;
        let inlineRegistryPromise = null;
        let registryCache = null;

        const MARATHON_DEFAULT_MESSAGE = 'Launch the arcade marathon to start the run.';

        const marathonState = {
          active: false,
          applets: [],
          index: -1,
          wins: 0,
          sessionId: null,
          frame: null,
          readyTimeout: null,
          timerInterval: null,
          timeoutHandle: null,
          deadline: 0,
          resultHandled: false,
          currentApplet: null,
          timeBudgetMs: 0
        };

        const focusElement = (element) => {
          if (!element || typeof element.focus !== 'function') return;
          try {
            element.focus({ preventScroll: true });
          } catch (error) {
            element.focus();
          }
        };

        const setScreenMode = (mode) => {
          const isMenu = mode === 'menu';
          const isBrowser = mode === 'browser';
          const isMarathon = mode === 'marathon';

          menuPanel.hidden = !isMenu;
          browserPanel.hidden = !isBrowser;
          marathonPanel.hidden = !isMarathon;

          screenBody.classList.toggle('screen-body--browser', isBrowser);
          screenBody.classList.toggle('screen-body--marathon', isMarathon);
        };

        const renderStatus = (message) => {
          appletGrid.innerHTML = '';
          const statusItem = document.createElement('li');
          statusItem.className = 'applet-grid__status';
          statusItem.textContent = message;
          appletGrid.appendChild(statusItem);
        };

        const resetMarathonUi = () => {
          marathonPanel.classList.remove('marathon-panel--failed', 'marathon-panel--complete');
          marathonFrameSlot.innerHTML = '';
          marathonMessage.textContent = MARATHON_DEFAULT_MESSAGE;
          marathonWins.textContent = '0';
          marathonCurrent.textContent = '---';
          marathonTotal.textContent = '0';
        };

        const loadInlineRegistry = () => {
          if (inlineRegistryPromise) {
            return inlineRegistryPromise;
          }

          inlineRegistryPromise = new Promise((resolve, reject) => {
            if (Array.isArray(window.__APPLET_REGISTRY__)) {
              resolve(window.__APPLET_REGISTRY__);
              return;
            }

            const script = document.createElement('script');
            script.src = '../registry/applets-inline.js';
            script.async = true;

            script.onload = () => {
              if (Array.isArray(window.__APPLET_REGISTRY__)) {
                resolve(window.__APPLET_REGISTRY__);
              } else {
                reject(new Error('Inline registry script loaded but no registry was found.'));
              }
            };

            script.onerror = () => {
              reject(new Error('Unable to load inline registry script.'));
            };

            document.head.appendChild(script);
          }).catch((error) => {
            inlineRegistryPromise = null;
            throw error;
          });

          return inlineRegistryPromise;
        };

        const loadRegistryData = async () => {
          try {
            const response = await fetch('../registry/applets.json');
            if (!response.ok) {
              throw new Error(`Unable to load registry (status ${response.status})`);
            }

            return await response.json();
          } catch (networkError) {
            const isFileProtocol = window.location?.protocol === 'file:';
            if (!isFileProtocol) {
              throw networkError;
            }

            try {
              const inlineRegistry = await loadInlineRegistry();
              return JSON.parse(JSON.stringify(inlineRegistry));
            } catch (inlineError) {
              console.error('Inline registry fallback failed.', inlineError);
              throw networkError;
            }
          }
        };

        const getRegistry = async () => {
          if (Array.isArray(registryCache)) {
            return registryCache;
          }

          const data = await loadRegistryData();
          registryCache = Array.isArray(data) ? data : [];
          return registryCache;
        };

        const loadRegistry = async () => {
          hasLoadedRegistry = true;
          renderStatus('Loading applet registry…');

          try {
            const applets = await getRegistry();
            if (!Array.isArray(applets) || applets.length === 0) {
              renderStatus('No applets registered yet.');
              return;
            }

            appletGrid.innerHTML = '';

            applets
              .slice()
              .sort((a, b) => a.name.localeCompare(b.name))
              .forEach((applet) => {
                if (!applet || !applet.name || !applet.entry) {
                  return;
                }

                const item = document.createElement('li');
                item.className = 'applet-card';

                const link = document.createElement('a');
                link.className = 'applet-link';

                const appletUrl = new URL(applet.entry, repoRootUrl);
                link.href = appletUrl.toString();
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                link.title = `Open ${applet.name}`;
                link.dataset.appletId = applet.id || '';

                const name = document.createElement('span');
                name.className = 'applet-name';
                name.textContent = applet.name;
                link.appendChild(name);

                const metaBits = [];
                if (Array.isArray(applet.difficulty) && applet.difficulty.length) {
                  metaBits.push(`Difficulty: ${applet.difficulty.join(' • ')}`);
                }
                if (typeof applet.minDurationMs === 'number' && typeof applet.maxDurationMs === 'number') {
                  const minSeconds = Math.round(applet.minDurationMs / 1000);
                  const maxSeconds = Math.round(applet.maxDurationMs / 1000);
                  metaBits.push(`Session: ${minSeconds}-${maxSeconds}s`);
                }

                if (metaBits.length) {
                  const meta = document.createElement('span');
                  meta.className = 'applet-meta';
                  meta.textContent = metaBits.join(' · ');
                  link.appendChild(meta);
                }

                if (applet.notes) {
                  const note = document.createElement('span');
                  note.className = 'applet-note';
                  note.textContent = applet.notes;
                  link.appendChild(note);
                }

                item.appendChild(link);
                appletGrid.appendChild(item);
              });

            if (!appletGrid.children.length) {
              renderStatus('Applets found but unable to render entries.');
            }
          } catch (error) {
            console.error('Failed to load applet registry.', error);
            hasLoadedRegistry = false;
            renderStatus('Failed to load applet registry.');
          }
        };

        const showBrowser = () => {
          if (marathonState.active) {
            return;
          }

          setScreenMode('browser');
          openButton.setAttribute('aria-pressed', 'true');
          startMarathonButton.setAttribute('aria-pressed', 'false');
          focusElement(closeButton);

          if (!hasLoadedRegistry) {
            loadRegistry();
          }
        };

        const hideBrowser = () => {
          setScreenMode('menu');
          openButton.setAttribute('aria-pressed', 'false');
          focusElement(openButton);
        };

        const chooseTimeBudget = (applet) => {
          const min = typeof applet?.minDurationMs === 'number' ? applet.minDurationMs : 15000;
          const max = typeof applet?.maxDurationMs === 'number' ? applet.maxDurationMs : min;
          const clampedMin = Math.max(5000, min);
          const clampedMax = Math.max(clampedMin, max);
          return Math.round((clampedMin + clampedMax) / 2);
        };

        const sendToApplet = (type, payload = {}) => {
          if (!marathonState.sessionId || !marathonState.frame?.contentWindow) {
            return;
          }
          marathonState.frame.contentWindow.postMessage(
            { type, sessionId: marathonState.sessionId, payload },
            '*'
          );
        };

        const clearMarathonTimers = () => {
          if (marathonState.readyTimeout) {
            clearTimeout(marathonState.readyTimeout);
            marathonState.readyTimeout = null;
          }
          if (marathonState.timerInterval) {
            clearInterval(marathonState.timerInterval);
            marathonState.timerInterval = null;
          }
          if (marathonState.timeoutHandle) {
            clearTimeout(marathonState.timeoutHandle);
            marathonState.timeoutHandle = null;
          }
        };

        const cleanupCurrentApplet = (forceEnd = false) => {
          clearMarathonTimers();

          if (forceEnd && marathonState.frame?.contentWindow && marathonState.sessionId) {
            try {
              marathonState.frame.contentWindow.postMessage(
                { type: 'host.end', sessionId: marathonState.sessionId, payload: { outcome: 'aborted' } },
                '*'
              );
            } catch (error) {
              console.warn('Unable to notify applet about marathon exit.', error);
            }
          }

          if (marathonState.frame) {
            marathonState.frame.remove();
            marathonState.frame = null;
          }

          marathonState.sessionId = null;
          marathonState.currentApplet = null;
          marathonState.timeBudgetMs = 0;
        };

        const handleAppletFailure = (outcome, reason) => {
          if (marathonState.resultHandled) {
            return;
          }

          const applet = marathonState.currentApplet;
          marathonState.resultHandled = true;
          marathonState.active = false;
          cleanupCurrentApplet();

          const total = marathonState.applets.length;
          const wins = marathonState.wins;
          const appletName = applet?.name || 'the game';

          let message = '';
          if (typeof reason === 'string' && reason.trim()) {
            message = reason.trim();
          } else if (outcome === 'timeout') {
            message = `Time expired during ${appletName}.`;
          } else {
            message = `${appletName} knocked you out.`;
          }

          marathonPanel.classList.remove('marathon-panel--complete');
          marathonPanel.classList.add('marathon-panel--failed');
          marathonMessage.textContent = `Marathon over! ${message} You cleared ${wins} of ${total} games.`;
          marathonCurrent.textContent = appletName;
          startMarathonButton.setAttribute('aria-pressed', 'false');
          openButton.disabled = false;
          focusElement(marathonExitButton);
        };

        const advanceToNextApplet = () => {
          if (!marathonState.active) {
            return;
          }

          cleanupCurrentApplet();
          marathonState.resultHandled = false;

          marathonState.index += 1;
          if (marathonState.index >= marathonState.applets.length) {
            marathonState.active = false;
            marathonPanel.classList.add('marathon-panel--complete');
            marathonPanel.classList.remove('marathon-panel--failed');
            marathonMessage.textContent = `Perfect run! You cleared all ${marathonState.applets.length} games!`;
            marathonCurrent.textContent = 'Complete';
            startMarathonButton.setAttribute('aria-pressed', 'false');
            openButton.disabled = false;
            focusElement(marathonExitButton);
            return;
          }

          const applet = marathonState.applets[marathonState.index];
          marathonState.currentApplet = applet;
          marathonCurrent.textContent = applet?.name || applet?.id || '---';
          marathonPanel.classList.remove('marathon-panel--failed', 'marathon-panel--complete');
          marathonFrameSlot.innerHTML = '';
          marathonMessage.textContent = `Loading ${applet?.name || 'next challenge'}…`;

          const frame = document.createElement('iframe');
          frame.className = 'marathon-frame';
          frame.setAttribute('tabindex', '-1');
          frame.title = `${applet?.name || 'Mini game'} viewport`;

          try {
            const appletUrl = new URL(applet.entry, repoRootUrl);
            frame.src = appletUrl.toString();
          } catch (error) {
            console.error('Failed to resolve applet URL.', error);
            handleAppletFailure('error', 'Unable to load the next game.');
            return;
          }

          frame.addEventListener('load', () => {
            if (!marathonState.active || marathonState.frame !== frame) {
              return;
            }

            const sessionId = `marathon-${applet.id || marathonState.index}-${Date.now()}`;
            marathonState.sessionId = sessionId;
            marathonState.timeBudgetMs = chooseTimeBudget(applet);

            const difficulty =
              (Array.isArray(applet?.difficulty) && applet.difficulty.length && applet.difficulty[0]) || 'easy';

            const payload = {
              appletId: applet.id || '',
              version: applet.version || '1.0.0',
              seed: Date.now() + marathonState.index * 17,
              difficulty,
              timeBudgetMs: marathonState.timeBudgetMs,
              capabilities: {}
            };

            sendToApplet('host.bootstrap', payload);

            clearMarathonTimers();
            marathonState.readyTimeout = window.setTimeout(() => {
              if (marathonState.active && marathonState.sessionId === sessionId && !marathonState.resultHandled) {
                handleAppletFailure('error', 'The game never reported ready.');
              }
            }, 3200);
          });

          marathonFrameSlot.appendChild(frame);
          marathonState.frame = frame;
        };

        const startActiveApplet = () => {
          if (!marathonState.active || !marathonState.currentApplet || marathonState.resultHandled) {
            return;
          }

          clearMarathonTimers();

          const difficulty =
            (Array.isArray(marathonState.currentApplet.difficulty) &&
              marathonState.currentApplet.difficulty.length &&
              marathonState.currentApplet.difficulty[0]) ||
            'easy';

          const timeBudget = marathonState.timeBudgetMs || chooseTimeBudget(marathonState.currentApplet);
          marathonState.timeBudgetMs = timeBudget;
          marathonState.deadline = performance.now() + timeBudget;

          marathonMessage.textContent = 'Go!';
          sendToApplet('host.setDifficulty', { level: difficulty });
          sendToApplet('host.setTimeBudget', { remainingMs: timeBudget });
          sendToApplet('host.start');

          marathonState.timerInterval = window.setInterval(() => {
            if (!marathonState.sessionId || marathonState.resultHandled) {
              return;
            }

            const remaining = Math.max(0, Math.round(marathonState.deadline - performance.now()));
            sendToApplet('host.setTimeBudget', { remainingMs: remaining });

            if (remaining <= 0) {
              clearInterval(marathonState.timerInterval);
              marathonState.timerInterval = null;
            }
          }, 500);

          marathonState.timeoutHandle = window.setTimeout(() => {
            if (!marathonState.resultHandled) {
              sendToApplet('host.end', { outcome: 'timeout' });
              handleAppletFailure('timeout');
            }
          }, timeBudget + 1200);
        };

        const handleAppletResult = (payload) => {
          if (marathonState.resultHandled) {
            return;
          }

          const outcome = payload?.outcome;
          if (outcome === 'success') {
            marathonState.resultHandled = true;
            marathonState.wins += 1;
            marathonWins.textContent = String(marathonState.wins);

            const appletName = marathonState.currentApplet?.name || 'the game';
            marathonMessage.textContent = `Cleared ${appletName}!`;

            cleanupCurrentApplet();

            window.setTimeout(() => {
              marathonState.resultHandled = false;
              if (marathonState.active) {
                advanceToNextApplet();
              }
            }, 900);
          } else {
            handleAppletFailure(outcome || 'fail', payload?.reason);
          }
        };

        const startMarathon = async () => {
          if (marathonState.active) {
            return;
          }

          openButton.disabled = true;
          startMarathonButton.setAttribute('aria-pressed', 'true');
          setScreenMode('marathon');
          marathonFrameSlot.innerHTML = '';
          marathonPanel.classList.remove('marathon-panel--failed', 'marathon-panel--complete');
          marathonMessage.textContent = 'Preparing marathon playlist…';
          marathonWins.textContent = '0';
          marathonCurrent.textContent = '---';
          marathonTotal.textContent = '0';

          let playlist = [];
          try {
            const applets = await getRegistry();
            playlist = (Array.isArray(applets) ? applets : []).filter((applet) => applet && applet.entry);
          } catch (error) {
            console.error('Unable to load registry for marathon.', error);
            marathonMessage.textContent = 'Unable to load the game registry.';
            marathonPanel.classList.add('marathon-panel--failed');
            startMarathonButton.setAttribute('aria-pressed', 'false');
            openButton.disabled = false;
            focusElement(startMarathonButton);
            return;
          }

          if (!playlist.length) {
            marathonMessage.textContent = 'No games are registered yet for the marathon.';
            marathonPanel.classList.add('marathon-panel--failed');
            startMarathonButton.setAttribute('aria-pressed', 'false');
            openButton.disabled = false;
            focusElement(startMarathonButton);
            return;
          }

          marathonState.active = true;
          marathonState.applets = playlist.slice();
          marathonState.index = -1;
          marathonState.wins = 0;
          marathonState.resultHandled = false;
          marathonState.sessionId = null;
          marathonState.currentApplet = null;
          marathonState.frame = null;
          marathonTotal.textContent = String(playlist.length);
          focusElement(marathonExitButton);

          advanceToNextApplet();
        };

        const exitMarathon = () => {
          const wasActive = marathonState.active;
          marathonState.active = false;
          marathonState.applets = [];
          marathonState.index = -1;
          marathonState.wins = 0;
          marathonState.resultHandled = false;

          cleanupCurrentApplet(wasActive);
          openButton.disabled = false;
          startMarathonButton.setAttribute('aria-pressed', 'false');
          setScreenMode('menu');
          resetMarathonUi();
          focusElement(startMarathonButton);
        };

        window.addEventListener('message', (event) => {
          if (!marathonState.frame || event.source !== marathonState.frame.contentWindow) {
            return;
          }

          const data = event.data;
          if (!data || typeof data !== 'object') {
            return;
          }

          if (data.sessionId && data.sessionId !== marathonState.sessionId) {
            return;
          }

          switch (data.type) {
            case 'applet.ready':
              marathonState.readyTimeout && clearTimeout(marathonState.readyTimeout);
              marathonState.readyTimeout = null;
              startActiveApplet();
              break;
            case 'applet.result':
              handleAppletResult(data.payload || {});
              break;
            case 'applet.error':
              handleAppletFailure('error', data.payload?.message);
              break;
            default:
              break;
          }
        });

        openButton.addEventListener('click', showBrowser);
        closeButton.addEventListener('click', hideBrowser);
        browserPanel.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            hideBrowser();
          }
        });

        startMarathonButton.addEventListener('click', startMarathon);
        marathonExitButton.addEventListener('click', exitMarathon);

        resetMarathonUi();
      })();
    </script>

  </body>
</html>
