<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>100 Games in 1 - Retro TV Dashboard</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <main class="viewport">
      <div class="scanlines"></div>
      <section class="tv-shell" aria-label="Retro television dashboard">
        <div class="tv-chrome">
          <div class="tv-bezel">
            <div class="tv-screen" role="presentation">
              <div class="screen-overlay"></div>
              <div class="screen-content">
                <header class="screen-header">
                  <p class="session-label">Session 1987-A</p>
                  <p class="clock">12:00</p>
                </header>
                <div class="screen-body">
                  <div class="screen-panel screen-panel--menu" data-panel="menu">
                    <div class="title-logo">
                      <span class="logo-shadow">100</span>
                      <span class="logo-main">100</span>
                      <span class="logo-sub">Games in 1</span>
                    </div>
                    <div class="menu-frame">
                      <p class="menu-label">Agent Update Queue</p>
                      <ul class="menu-list" role="menu">
                        <li class="menu-item active" role="menuitem">
                          Quick Tap — Rapid reflex target chase
                        </li>
                        <li class="menu-item" role="menuitem">
                          Color Match — Align swatches before the timer fades
                        </li>
                        <li class="menu-item" role="menuitem">
                          Orb Dodge — Weave through incoming cosmic hazards
                        </li>
                        <li class="menu-item" role="menuitem">
                          Snake Sprint — Dash to the flashing snack in 10s
                        </li>
                      </ul>
                    </div>
                    <footer class="screen-footer">
                      <p>Insert coin or press start to begin.</p>
                    </footer>
                  </div>
                  <div class="screen-panel screen-panel--browser" data-panel="browser" hidden>
                    <div class="browser-header">
                      <p class="browser-title">Test Cabinet</p>
                      <button type="button" class="browser-close" aria-label="Return to dashboard">Back</button>
                    </div>
                    <p class="browser-subtitle">Select a game to launch a standalone playtest window.</p>
                    <ul class="applet-grid" role="list"></ul>
                    <p class="browser-hint">Games open in a new tab so you can focus on the chosen build.</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <aside class="control-column" aria-label="Television controls">
            <div class="control-group">
              <button class="knob knob--large" aria-label="Power knob"></button>
              <div class="knob-label">Power</div>
            </div>
            <div class="control-group">
              <button class="knob knob--medium" aria-label="Playlist select"></button>
              <div class="knob-label">Playlist</div>
            </div>
            <div class="control-group">
              <button class="knob knob--small" aria-label="Volume"></button>
              <div class="knob-label">Volume</div>
            </div>
            <div class="control-stack">
              <button class="job-pill" type="button" id="open-game-browser">Test cabinet · browse applets</button>
              <button class="job-pill" type="button">Color Match · polish palette hints</button>
              <button class="job-pill" type="button">Snake Sprint · verify countdown tuning</button>
            </div>
          </aside>
        </div>
        <div class="tv-base"></div>
        <div class="glow halo"></div>
        <div class="glow ambient"></div>
      </section>
    </main>
    <script>
      (() => {
        const openButton = document.getElementById('open-game-browser');
        const menuPanel = document.querySelector('[data-panel="menu"]');
        const browserPanel = document.querySelector('[data-panel="browser"]');
        const closeButton = browserPanel?.querySelector('.browser-close');
        const screenBody = document.querySelector('.screen-body');
        const appletGrid = browserPanel?.querySelector('.applet-grid');

        if (!openButton || !menuPanel || !browserPanel || !closeButton || !screenBody || !appletGrid) {
          return;
        }

        let hasLoadedRegistry = false;
        let inlineRegistryPromise = null;

        const focusElement = (element) => {
          if (!element || typeof element.focus !== 'function') return;
          try {
            element.focus({ preventScroll: true });
          } catch (error) {
            element.focus();
          }
        };

        const renderStatus = (message) => {
          appletGrid.innerHTML = '';
          const statusItem = document.createElement('li');
          statusItem.className = 'applet-grid__status';
          statusItem.textContent = message;
          appletGrid.appendChild(statusItem);
        };

        const showBrowser = () => {
          menuPanel.hidden = true;
          browserPanel.hidden = false;
          screenBody.classList.add('screen-body--browser');
          openButton.setAttribute('aria-pressed', 'true');
          focusElement(closeButton);

          if (!hasLoadedRegistry) {
            loadRegistry();
          }
        };

        const hideBrowser = () => {
          browserPanel.hidden = true;
          menuPanel.hidden = false;
          screenBody.classList.remove('screen-body--browser');
          openButton.setAttribute('aria-pressed', 'false');
          focusElement(openButton);
        };

        const loadInlineRegistry = () => {
          if (inlineRegistryPromise) {
            return inlineRegistryPromise;
          }

          inlineRegistryPromise = new Promise((resolve, reject) => {
            if (Array.isArray(window.__APPLET_REGISTRY__)) {
              resolve(window.__APPLET_REGISTRY__);
              return;
            }

            const script = document.createElement('script');
            script.src = '../registry/applets-inline.js';
            script.async = true;

            script.onload = () => {
              if (Array.isArray(window.__APPLET_REGISTRY__)) {
                resolve(window.__APPLET_REGISTRY__);
              } else {
                reject(new Error('Inline registry script loaded but no registry was found.'));
              }
            };

            script.onerror = () => {
              reject(new Error('Unable to load inline registry script.'));
            };

            document.head.appendChild(script);
          }).catch((error) => {
            inlineRegistryPromise = null;
            throw error;
          });

          return inlineRegistryPromise;
        };

        const loadRegistryData = async () => {
          try {
            const response = await fetch('../registry/applets.json');
            if (!response.ok) {
              throw new Error(`Unable to load registry (status ${response.status})`);
            }

            return await response.json();
          } catch (networkError) {
            const isFileProtocol = window.location?.protocol === 'file:';
            if (!isFileProtocol) {
              throw networkError;
            }

            try {
              const inlineRegistry = await loadInlineRegistry();
              return JSON.parse(JSON.stringify(inlineRegistry));
            } catch (inlineError) {
              console.error('Inline registry fallback failed.', inlineError);
              throw networkError;
            }
          }
        };

        const loadRegistry = async () => {
          hasLoadedRegistry = true;
          renderStatus('Loading applet registry…');

          try {
            const applets = await loadRegistryData();
            if (!Array.isArray(applets) || applets.length === 0) {
              renderStatus('No applets registered yet.');
              return;
            }

            appletGrid.innerHTML = '';

            applets
              .slice()
              .sort((a, b) => a.name.localeCompare(b.name))
              .forEach((applet) => {
                if (!applet || !applet.name || !applet.entry) {
                  return;
                }

                const item = document.createElement('li');
                item.className = 'applet-card';

                const link = document.createElement('a');
                link.className = 'applet-link';
                link.href = `../${applet.entry}`;
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                link.title = `Open ${applet.name}`;
                link.dataset.appletId = applet.id || '';

                const name = document.createElement('span');
                name.className = 'applet-name';
                name.textContent = applet.name;
                link.appendChild(name);

                const metaBits = [];
                if (Array.isArray(applet.difficulty) && applet.difficulty.length) {
                  metaBits.push(`Difficulty: ${applet.difficulty.join(' • ')}`);
                }
                if (typeof applet.minDurationMs === 'number' && typeof applet.maxDurationMs === 'number') {
                  const minSeconds = Math.round(applet.minDurationMs / 1000);
                  const maxSeconds = Math.round(applet.maxDurationMs / 1000);
                  metaBits.push(`Session: ${minSeconds}-${maxSeconds}s`);
                }

                if (metaBits.length) {
                  const meta = document.createElement('span');
                  meta.className = 'applet-meta';
                  meta.textContent = metaBits.join(' · ');
                  link.appendChild(meta);
                }

                if (applet.notes) {
                  const note = document.createElement('span');
                  note.className = 'applet-note';
                  note.textContent = applet.notes;
                  link.appendChild(note);
                }

                item.appendChild(link);
                appletGrid.appendChild(item);
              });

            if (!appletGrid.children.length) {
              renderStatus('Applets found but unable to render entries.');
            }
          } catch (error) {
            console.error('Failed to load applet registry.', error);
            renderStatus('Failed to load applet registry.');
          }
        };

        openButton.addEventListener('click', showBrowser);
        closeButton.addEventListener('click', hideBrowser);
        browserPanel.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            hideBrowser();
          }
        });
      })();
    </script>
  </body>
</html>
